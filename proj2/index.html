<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Vincent Lee, Kevin Xiong</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    [TODO OVERVIEW]
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

<p>
    We used de Casteljau’s algorithm to evaluate Bezier curves. De Casteljau’s algorithm is where you linearly interpolate between the control points on a parameter t. You can keep doing this recursively and the lowest recursion level will be a single point that lies on the Bezier curve. If you keep feeding in different values of t (between 0 and 1), it will trace out the Bezier curve. We were able to implement this algorithm by iterating through a list of points and linearly interpolating adjacent points in the list. We then save the results in a list that we can use to run the algorithm again.

</p>
<br>


<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<!-- Example of including a single figure -->
<div align="middle">
  <img src="images/your_file.png" align="middle" width="50%">
</div>
<br>

<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 0</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 1</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 2</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 3</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 4</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>  
<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<p>
    With surfaces, you can treat it as a list of list points that define a Bezier curve. To make de Casteljau’s algorithm work with surfaces, you will need two parameter values u and v. You will use u to run the algorithm on each list. This will result in a list of points which can be used to run the algorithm again with v to get a point that lies on the Bezier surface. To do this in code, we iterated through a 2d array. We ran de Casteljau’s algorithm on each row with parameter u and combined the results in a single list. We then ran the algorithm again with v to return a point on the Bezier surface.

</p>
<br>


<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<p>
    To implement area weighted vertices, we use the loop traversal method shown in discussion. This was done by first getting the starting vertex. SInce each vertex points to a halfedge, we use the halfedge variable in Vertex to get the starting point. To get the next vertex, we get the vertex of the twin’s next() halfedge and repeat until we return to our starting vertex. During iteration, we keep track of variables curr and prev that point to the current vertex and the previous loop’s vertex. With the starting vertex, these are used to calculate the area of each triangle using the formula A = 0.5(a x b + b x c + c x a) where a, b, and c are the vectors between each vertex. Then, we find its norm and proceed with the process described in the spec. We have a variable retVal that tracks the sum of the weights, and at the end, we normalize and return it. In the images below, the top image is without weighted shading, and the bottom is with weighted shading. As shown, the bottom image has gradual shading on each of the planes of the object, giving it a smoother look.
</p>
<br>


<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<p>
    Since there are many objects to keep track of, we started by creating a variable pointing to every halfedge, vertex, edge, and face associated with the two triangles. Then, we reassigned the variables according to the first image below. For example, for h1, we would have h1->setNeighbors(h2, h7, v2, e2, f0). We did this for every object involved even for assignments that do not change, ensuring that no object is forgotten. The second and third images show before and after edge flip.

</p>
<br>


<b>
  Show screenshots of the teapot before and after some edge flips.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
<b>
    Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


</body>
</html>